// this is a simple shell 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdbool.h>
#include <signal.h>
#include <time.h>
// declaring size for history 
#define MAX_HISTORY_SIZE 100
//defining the structure of history 
struct CommandHistory {
    char command[20000];//array to store name
//time for statting and ending 
    time_t start_time;
    time_t end_time;
    pid_t pid;//pid of the process
};
//declaring and initialising  history data structure
struct CommandHistory history[MAX_HISTORY_SIZE];
int history_index = 0;


//function to show command history((brief))
void his(){
     printf("\nCommand History:\n");
    for (int i = 0; i < history_index; i++) {
        printf("Command: %s", history[i].command);
}
}
//this function handles the signal generated by press ctrl c and prints the detailed command history
void signal_handler(int signum) {
    printf("\nDetailed Command History:\n");
    for (int i = 0; i < history_index; i++) {
        printf("Command: %s", history[i].command);
        printf("Start :");
        printf("Time:  %s", ctime(&history[i].start_time));
        printf("End Time: %s", ctime(&history[i].end_time));
        printf("PID: %d\n", history[i].pid);
        printf("\n");
    }
    exit(0);
}
// this function reads the user input using the fgets command and storing them in an array
int readcommand(char *command) {
    if (fgets(command, 20000, stdin) == NULL) {
        return 0;
    }
    
    return 1;
    
}
//this function is parce the command into small sub arguments using the strok func 
//and storing them into ythe argument array(pointed)
void parsecmd_pipe(char *command, char **argument) {
    int numarg = 0;
    char *word = strtok(command, " \n"); // Use " \n" to tokenize words and remove the newline character
    while (word != NULL && numarg < 200) {
        argument[(numarg)++] = word;
        word = strtok(NULL, " \n");
    }
    argument[numarg] = NULL;
}

void parsecmd(char *command, char **argument, int *numarg) {
    *numarg = 0;
    char *word = strtok(command, " \n"); // Use " \n" to tokenize words and remove the newline character
    while (word != NULL && *numarg < 200) {
        argument[(*numarg)++] = word;
        word = strtok(NULL, " \n");
    }
    argument[*numarg] = NULL;
}
// function to execute simple commands (commands that are not piped)
void executesimplecommand(char **argument) {
   char fullcommand[20000] = "";
    pid_t pid = fork();//forking 
    if (pid < 0) {
        perror("Fork failed");//error while forking
        exit(1);
    } else if (pid == 0) {
        //child process
        if (execvp(argument[0], argument) < 0) {
            perror("Exec failed");
            exit(1);
        }
    } else {
        //parent process
        wait(NULL);// waiting for the child to die
        
    }
    
}
//function to check whether the command given is piped or not
int checkpipe(char *command) {
    int length = strlen(command);
    for (int i = 0; i < length; i++) {
        if (command[i] == '|') {
            return 1; // Return 1 to indicate a pipe is found
        }
    }
    return 0; // Return 0 if no pipe is found
}
int countpipe(char *command) {
    int count=0;
    int length = strlen(command);
    for (int i = 0; i < length; i++) {
        if (command[i] == '|') {
            count ++; // Return 1 to indicate a pipe is found
        }
    }
    return count; // Return 0 if no pipe is found
}
//function to parce the command that has pipelining
int parsepipe(char *argument, char **pipeargument) {
    int num = 0;
    char *cmds = strtok(argument, "|");
    while ((cmds != NULL) && num < 200) {
        pipeargument[num++] = cmds;
        cmds = strtok(NULL, "|");
    }
    return num;
}

//function to execute piped command 
void execute_piped_commands(int num_of_piped_commands, char **pipeargument) {
    int pipes[2];//creating the array for read and write discriptor
    int prev_read = 0;//for storing previos pipe line command
    char full_command[20000] = ""; // To store the full piped command

    for (int i = 0; i < num_of_piped_commands; i++) {
        if (pipe(pipes) < 0) {
            perror("Pipe creation failed");// error while making the pipe
            exit(1);
        }
        //creating n child processes
        pid_t pid = fork();
        if (pid < 0) {
            perror("Fork failed");
            exit(1);
        } else if (pid == 0) {
            if (i > 0) {//child process
                dup2(prev_read, 0); // Redirect stdin from the previous pipe
                close(prev_read);
            }

            if (i < num_of_piped_commands - 1) {
                dup2(pipes[1], 1); // Redirect stdout to the current pipe
                close(pipes[1]);//closing pipes
            }
            close(pipes[0]);//In the child process, it closes the read end of the pipe because it will be writing to the pipe.

            char *cmd_args[200];
            parsecmd_pipe(pipeargument[i], cmd_args);
            if (execvp(cmd_args[0], cmd_args) < 0) {
                perror("Exec failed");
                exit(1);
            }
        } else {
            prev_read = pipes[0];//waiting for the child process to terminate
            close(pipes[1]);//In the parent process, it closes the write end of the pipe because it will be reading to the pipe.
            wait(NULL);
        }

        // Concatenate the piped command to the full command
        if (i == 0) {
            strcpy(full_command, pipeargument[i]);
        } else {
            strcat(full_command, " | ");
            strcat(full_command, pipeargument[i]);
        }
    }

    // Record the start time for the piped command group
    time_t start_time = time(NULL);

    // Record the end time for the piped command group
    time_t end_time = time(NULL);

    // Store the piped command  history
    if (history_index < MAX_HISTORY_SIZE) {
        strncpy(history[history_index].command, full_command, sizeof(history[history_index].command) - 1);
        history[history_index].command[sizeof(history[history_index].command) - 1] = '\0';
        history[history_index].start_time = start_time;
        history[history_index].end_time = end_time;
        history[history_index].pid = getpid(); 
        history_index++;
    } 
}

int main() {
    // Set up the SIGINT (Ctrl+C) signal handler
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);

    char command[20000];//creating an command array for storing 
    char *argument[200];//declaring argument as an array of pointers to characters
    char *pipeargument[200];
    int numarg;
    int no_of_piped_commands;//for no. of pipes in a command  
//infinite loop for shell
    while (true) {
        printf("\nJarvis@system:~$ ");//naming the command prompt
        if (readcommand(command) == 0) {
            break;
        }
        //handling history command
        if(strcmp(command,"history\n")==0){
            his();
            continue;
        }

        int pipecheck = checkpipe(command);
        //check whether piped or not
         int j=countpipe(command);
        if (pipecheck) {
            no_of_piped_commands = parsepipe(command, pipeargument);//if piped calculating no. of pipes

           
             execute_piped_commands(no_of_piped_commands, pipeargument);// function call for executing piped command

        } else {
            char * name = strdup(command);//duplicting the command name for storing in history
            parsecmd(command, argument, &numarg);//parse the command using space

            time_t start_time = time(NULL); // Record the start time
            pid_t pid = fork();//forking

            if (pid < 0) {
                perror("Fork failed");//forking error
                exit(1);
            } else if (pid == 0) {//child process
                executesimplecommand(argument);
                exit(0);//sending signal to parent act as an obedient child
            } else {
                wait(NULL);//parent waits for the child 
                time_t end_time = time(NULL); // Record the end time

                if (history_index < MAX_HISTORY_SIZE) {
                    // Store the command history
                    strncpy(history[history_index].command, name, sizeof(history[history_index].command) - 1);
                    history[history_index].command[sizeof(history[history_index].command) - 1] = '\0';
                    history[history_index].start_time = start_time;
                    history[history_index].end_time = end_time;
                    history[history_index].pid = pid;
                    history_index++;
                } else {
                    printf("Command history is full.\n");
             }
            }
        }
    }
    return 0;
}
